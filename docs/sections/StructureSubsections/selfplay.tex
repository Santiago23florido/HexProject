\subsection{Self-play}
On inclut dans cette section ce qui concerne l’entraînement avec reinforcement learning du modèle pour l’estimation du score qui est employé dans le Negamax du modèle heuristique en utilisant la MLP. RLTrainer, dont le rôle (du point de vue de la POO) est d’encapsuler tout le cycle d’entraînement par auto-jeu : configurer le modèle, générer des parties, transformer les parties en données, entraîner le réseau et sauvegarder/exporter les résultats. Dans le constructeur il applique la validation des invariants de configuration (cfg\_), initialise les dépendances (modèle ValueMLP, optimizer, replay buffer) et sélectionne le dispositif (CPU/CUDA). Il maintient aussi deux instances du modèle : model\_ (entraînement) et evalModel\_ (évaluation), séparées pour la stabilité.
La partie d’auto-jeu utilise le polymorphisme via l’interface IMoveStrategy : l’entraîneur n’a pas besoin de savoir s’il joue un NegamaxStrategy ou un NegamaxHeuristicStrategy ; il appelle seulement select(...). Dans playOneGame on joue une partie complète, et à chaque tour on sauvegarde un EpisodeState (features + joueur au tour) dans un episode. Ensuite addEpisodeToBuffer parcourt l’épisode et le convertit en échantillons d’entraînement (ReplaySample) avec une cible basée sur le gagnant final, et les insère dans un replay buffer, en séparant clairement la responsabilité de “générer l’expérience” et de “la stocker”.
Finalement, trainUpdates réalise les étapes d’apprentissage : il échantillonne des batches du replay buffer, construit des tenseurs x (features) et y (targets), fait le forward, calcule la perte, rétro-propage et met à jour les poids avec AdamW, en appliquant du clipping pour la stabilité. Après l’entraînement, il synchronise evalModel\_ en copiant les paramètres et les buffers (avec NoGradGuard) pour que l’évaluation soit cohérente, et optionnellement crée des snapshots “frozen” pour la diversité des adversaires. Le fichier inclut aussi des responsabilités de persistance (checkpoints) et de sérialisation (export TorchScript + smoke test), complétant le pipeline dans une seule classe cohésive.
