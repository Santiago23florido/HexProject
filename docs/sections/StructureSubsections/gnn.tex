\subsection{Mlp-gnn}

Dans cette section on inclut les éléments liés à la représentation en graphe du plateau et en plus à l’implémentation du calcul du score de mouvement au moyen de la stratégie d’IA qui implique une MLP ou celle qui implique un réseau neuronal de graphes. Les classes principales du module gnn sont résumées ci-dessous.

\begin{table}[h]
\centering
{\footnotesize
\setlength{\tabcolsep}{3pt}
\begin{tabular}{@{}p{0.21\columnwidth} p{0.30\columnwidth} p{0.38\columnwidth}@{}}
\hline
Classe & Derivees directes /\\ specialisations & Description \\
\hline
Graph (structure) &  & Graphe du plateau (adjacences, features, super-nœuds). \\
NodeFeatures (structure) &  & Vecteur de features par nœud (pions, bords, distances, joueur). \\
FeatureBatch (structure) &  & Tenseurs aplatis prêts pour l’évaluation GNN/MLP. \\
FeatureExtractor (classe) &  & Construit le graphe et produit les batches (cache par taille). \\
GNNModel (classe) &  & Wrapper TorchScript pour évaluer un modèle GNN/MLP. \\
\hline
\end{tabular}
}
\caption{Panorama des classes du module gnn.}
\end{table}

On implémente la classe graphe et on utilise la définition cubique pour l’identification des voisins de chaque nœud Mettre à jour les features dynamiques qui dépendent bien de la partie actuelle:p1 = 1 si la cellule a une pièce du joueur 1
p2 = 1 si elle a une pièce du joueur 2
empty = 1 si elle est vide, cela se trouve dans les fichiers Graph.hpp et Graph.cpp

On transforme un état du plateau en un batch de données l’état du jeu , en construisant un graphe pour représenter l’état du jeu on convertit le graphe en un feature batch, puis après avoir aplati les caractéristiques du nœud et les arêtes du graphe. dans les fichiers FeaureStractoo hpp et FeatureExtracto.cpp, finalement dans ce dossier on implémente un wrapper C++ sur le modèle de PyTorch qui a la GNN ou sur la MLP dans une classe GNNNModel en TorchScript, le forward a des arguments; ici ils comptent combien d’inputs réels il reçoit (sans le self implicite).
<<<<<<< HEAD
Puis on l’utilise pour :expectsEdgeIndex(): si le forward attend au moins 2 inputs, on assume qu’il a besoin de edge\_index. ce qui permet de différencier quel modèle est chargé dans MoveStrategy dans la méthode de l’évaluation, on définit aussi les méthodes de requête et d’évaluation du modèle dans le cas où il s’agit d’une GNN en prenant un batch de nœuds par features et d’arêtes, en construisant un tenseur, on incorpore aussi l’évaluation pour la MLP`, qui ce qu’elle fait est de copier les features dans le tenseur et fait l’estimation. qui se trouve dans les fichiers GNNModle.cpp et GNNNModel.hpp
=======
Puis on l’utilise pour :expectsEdgeIndex(): si le forward attend au moins 2 inputs, on assume qu’il a besoin de edge\_index. ce qui permet de différencier quel modèle est chargé dans MoveStrategy dans la méthode de l’évaluation, on définit aussi les méthodes de requête et d’évaluation du modèle dans le cas où il s’agit d’une GNN en prenant un batch de nœuds par features et d’arêtes, en construisant un tenseur, on incorpore aussi l’évaluation pour la MLP`, qui ce qu’elle fait est de copier les features dans le tenseur et fait l’estimation. qui se trouve dans les fichiers GNNModel.cpp et GNNNModel.hpp
>>>>>>> main
